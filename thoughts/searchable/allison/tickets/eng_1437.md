
[ENG-1437] Determine and implement path for unifying and forking sessions
Status: Done
Assignee: allison@humanlayer.dev

Description:
* Think about how to display sessions (if there are multiple). 
  * Potential to nest any parent sessions in the children instead of displaying them directly. 
  * If there are no forks (only a single line of parent/children) then it would make sense to potentially just display the newest child and hide the others.
  * it  could make sense to allow something similar to claude code interactive `double escape`, where you can choose previous user messages to jump back to. How this would function is basically when the wui selects a user message, it would jump to the parent above the first time that session was created, and put the query from the child as an in-progress (being typed) message. When you do this, this would effectively "make the first fork". At this point display is a little more confusing. You'd need logic on the frontend to detect this and display the newest session for the 2 trees in the fork. Then do the same logic again if there happens to be a third.

If a single child<->parent has no forks yet, then treat the getSessionList and getConversation as if it's only the most recent (none of the parents show up):
If the client doesn't have a full list of session ids (including all parents), then it can't effectively fork (because it doesn't know the parent ids).

Parent id 1:
   Child ID 2:
     Child ID 3:

User is at the end of Child ID 3, They want to fork off of previous messages. They double escape to go to the original Parent ID 1 User message. 

```
  {
      "id": 1103,
      "session_id": "f9d0d766-0087-4ae5-8b43-11160d602d6c",
      "claude_session_id": "38a012a2-18a8-4db4-a1f3-842455ef0a90",
      "sequence": 1,
      "event_type": "message",
      "created_at": "2025-06-24T18:07:39Z",
      "role": "assistant",
      "content": "I'll explore the codebase to understand its structure and purpose. Let me start by examining the repository structure and key files.",
      "is_completed": false
  }The pieces of the below that are most important for this ticket is specifically the "User message injected" portion.Research for query inheritance:
```

[https://github.com/humanlayer/thoughts/blob/main/repos/humanlayer/shared/research/2025-01-24_14-48-00_inject-query-plan-review.md](https://github.com/humanlayer/thoughts/blob/main/repos/humanlayer/shared/research/2025-01-24_14-48-00_inject-query-plan-review.md)
(Located locally at `thoughts/shared/research/…`

Plan for resumed inheritance:

[https://github.com/humanlayer/thoughts/blob/main/repos/humanlayer/allison/plans/inject-query-as-first-event.md](https://github.com/humanlayer/thoughts/blob/main/repos/humanlayer/allison/plans/inject-query-as-first-event.md)
(Located locally at `thoughts/allison/plans/…`

If it is forked: How do we treat it? How do we calculate trees? 
In this example:
Parent 1:
  Child 2:
    Child 3:
       Child 4:
   Child 5:
       Child 6:

In this example, we only show 2 sessions? Child 6 and 4. 

On frontend, when Child 6 gets continued, what happens to frontend state? This is what it updates to

Parent 1:
  Child 2:
    Child 3:
       Child 4:
   Child 5:
       Child 6:
          Child 7:


 Child 6 was a session that was returned via `getSessions` (or whatever) but now it won't be because Child 7 exists and is the only one returned from the child 5 tree. (Only child 7 and child 4 are returned). 

What the current question is:

How does the frontend deal with the fact that when a conversation is resumed, it needs to know one of two things:

* Either the new session ID that was created and update/invalidate any old IDs accordingly, to help mask the fork from the user
* OR, the API leans on some sort of `pointer_id` right from the start to steadily move the ID between leaves, removing the need for clients to be aware of new session IDs
* OR ??

Child 6:

```json
{
  pointer_id: 1
}
```

* Then, you resume a conversation at Child 6
* The HLD/daemon layer/API, forks a conversation *and* moves the pointer from 6 to the newly created 7

Comments:
[2025-06-24] allison@humanlayer.dev:
### Option 1: Backend Tree Calculation (Modify listSessions)

**Implementation**:

```go
// In handlers.go listSessions
sessions := manager.ListSessions()
trees := buildSessionTrees(sessions)
leafSessions := extractLeafNodes(trees)
return leafSessions
```

**Pros**:

* Single source of truth for tree logic
* Reduces network payload
* Consistent behavior across all clients

**Cons**:

* Breaking change to existing API
* Loses ability to see all sessions
* Complex tree calculation on every request

### Option 2: New Tree-Aware Endpoint

**Implementation**:

```go
// New endpoint: getSessionTrees
type SessionTree struct {
    Session     SessionInfo
    Children    []SessionTree
    HasForks    bool
    IsLeaf      bool
}
```

**Pros**:

* Non-breaking addition
* Rich tree structure for UI
* Can include fork metadata

**Cons**:

* Duplicates some logic
* Requires frontend changes
* More complex API surface

### Option 3: Frontend Tree Building (Current Approach)

**Implementation**:

```typescript
// In useSessions hook
const buildTree = (sessions: SessionInfo[]): SessionTree => {
  const map = new Map(sessions.map(s => [s.session_id, s]));
  const roots = [];
  const children = new Map<string, string[]>();
  
  sessions.forEach(s => {
    if (s.parent_session_id) {
      const siblings = children.get(s.parent_session_id) || [];
      siblings.push(s.session_id);
      children.set(s.parent_session_id, siblings);
    } else {
      roots.push(s);
    }
  });
  
  // Only show leaves unless forked
  return filterToLeaves(roots, children);
};
```

**Pros**:

* No backend changes needed
* Full flexibility in UI
* Can experiment with different visualizations

**Cons**:

* Logic duplication across clients
* Larger network payloads
* Client-side performance cost

### Option 4: Virtual Session IDs (Pointer Concept)

**Implementation**:

```go
// Add to Session model
type Session struct {
    ID           string
    VirtualID    string  // Pointer that moves to newest child
    RealID       string  // Actual session ID
}
```

**Pros**:

* Transparent to frontend
* Sessions appear to update in place
* No fork display logic needed

**Cons**:

* Complex ID management
* Breaking change to data model
* Harder to debug issues


View in Linear: https://linear.app/humanlayer/issue/ENG-1437/determine-and-implement-path-for-unifying-and-forking-sessions
