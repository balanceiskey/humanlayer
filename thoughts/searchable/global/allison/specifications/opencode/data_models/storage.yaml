---
component: Storage
version: "1.0.0"
category: Core Data Model
description: Persistent storage and data management
---

# Storage Data Model

## Overview
The Storage system provides persistent data storage for sessions, messages, and application state using a file-based storage backend with JSON serialization and atomic operations.

## Entity: Storage Management

### Purpose
- Provide persistent storage for application data
- Enable atomic write operations
- Support efficient data retrieval and listing
- Manage storage lifecycle and cleanup

### Core Interface
```typescript
namespace Storage {
  function writeJSON<T>(key: string, content: T): Promise<void>;
  function readJSON<T>(key: string): Promise<T>;
  function remove(key: string): Promise<void>;
  function removeDir(key: string): Promise<void>;
  function list(prefix: string): AsyncGenerator<string>;
}
```

### Storage Architecture

#### Directory Structure
```
~/.local/share/opencode/project/<project-hash>/storage/
├── session/
│   ├── info/
│   │   ├── ses_01h2k3....json       # Session metadata
│   │   └── ses_01h2k4....json
│   ├── message/
│   │   ├── ses_01h2k3.../
│   │   │   ├── msg_01h2k5....json   # Message data
│   │   │   └── msg_01h2k6....json
│   │   └── ses_01h2k4.../
│   └── share/
│       ├── ses_01h2k3....json       # Share credentials
│       └── ses_01h2k4....json
└── app.json                         # Application state
```

#### Project-based Storage
- **Global Storage**: `~/.local/share/opencode/project/global/`
- **Git Projects**: `~/.local/share/opencode/project/<git-hash>/`
- **Project Hash**: Deterministic hash from git repository path
- **Isolation**: Complete data isolation between projects

### Storage Operations

#### Write Operations
```typescript
async function writeJSON<T>(key: string, content: T): Promise<void> {
  const target = path.join(state().dir, key + ".json");
  const tmp = target + Date.now() + ".tmp";
  
  // Atomic write with temporary file
  await Bun.write(tmp, JSON.stringify(content));
  await fs.rename(tmp, target).catch(() => {});
  await fs.unlink(tmp).catch(() => {});
  
  // Emit storage event
  Bus.publish(Event.Write, { key, content });
}
```

#### Read Operations
```typescript
async function readJSON<T>(key: string): Promise<T> {
  const file = Bun.file(path.join(state().dir, key + ".json"));
  return file.json() as Promise<T>;
}
```

#### List Operations
```typescript
async function* list(prefix: string): AsyncGenerator<string> {
  try {
    const glob = new Bun.Glob("**/*");
    for await (const item of glob.scan({
      cwd: path.join(state().dir, prefix),
      onlyFiles: true,
    })) {
      const result = path.join(prefix, item.slice(0, -5)); // Remove .json
      yield result;
    }
  } catch {
    return; // Directory doesn't exist
  }
}
```

#### Removal Operations
```typescript
async function remove(key: string): Promise<void> {
  const target = path.join(state().dir, key + ".json");
  await fs.unlink(target).catch(() => {});
}

async function removeDir(key: string): Promise<void> {
  const target = path.join(state().dir, key);
  await fs.rm(target, { recursive: true, force: true }).catch(() => {});
}
```

### Data Organization

#### Hierarchical Keys
Storage uses hierarchical key structures for organization:

**Session Data:**
- `session/info/<sessionID>` - Session metadata
- `session/message/<sessionID>/<messageID>` - Message content
- `session/share/<sessionID>` - Sharing credentials

**Application Data:**
- `app` - Application state and configuration
- `cache/<key>` - Temporary cached data
- `user/<userID>` - User-specific data

#### Key Naming Conventions
- **Identifiers**: Use prefixed IDs (ses_, msg_, usr_)
- **Hierarchy**: Forward slash separation for namespaces
- **Extensions**: Automatic .json extension for files
- **Case Sensitivity**: Case-sensitive key matching

### Atomic Operations

#### Write Atomicity
```typescript
async function atomicWrite(path: string, content: string): Promise<void> {
  const tempPath = `${path}.${Date.now()}.tmp`;
  
  try {
    // Write to temporary file
    await Bun.write(tempPath, content);
    
    // Atomic rename to final location
    await fs.rename(tempPath, path);
  } catch (error) {
    // Cleanup temporary file on failure
    await fs.unlink(tempPath).catch(() => {});
    throw error;
  }
}
```

#### Transaction Support
While not implementing full ACID transactions, the storage system provides:
- **Atomic Writes**: Individual file writes are atomic
- **Isolation**: Per-project storage isolation
- **Consistency**: JSON schema validation
- **Durability**: Immediate file system sync

### Event System

#### Storage Events
```typescript
export const Event = {
  Write: Bus.event(
    "storage.write",
    z.object({ 
      key: z.string(), 
      content: z.any() 
    }),
  ),
};
```

#### Event Integration
```typescript
// Share synchronization triggered by storage events
Bus.subscribe(Storage.Event.Write, async (payload) => {
  const { key, content } = payload.properties;
  await Share.sync(key, content);
});
```

### Data Serialization

#### JSON Format
All data is stored as JSON with consistent formatting:
```json
{
  "id": "ses_01h2k3...",
  "title": "Session Title",
  "time": {
    "created": 1705315800000,
    "updated": 1705316400000
  }
}
```

#### Serialization Rules
- **Timestamps**: Unix milliseconds for all time values
- **IDs**: String-based prefixed identifiers
- **Optional Fields**: Omitted when undefined
- **Nested Objects**: Preserved structure
- **Arrays**: Maintained order

#### Schema Validation
Data is validated before storage using Zod schemas:
```typescript
async function writeValidated<T>(
  key: string, 
  content: T, 
  schema: z.ZodSchema<T>
): Promise<void> {
  const validated = schema.parse(content);
  await writeJSON(key, validated);
}
```

### Storage State Management

#### Application State
```typescript
const state = App.state("storage", () => {
  const app = App.info();
  const dir = path.join(app.path.data, "storage");
  
  return { dir };
});
```

#### Initialization
Storage is initialized per application context:
1. Determine project type (git vs global)
2. Create project-specific storage directory
3. Initialize storage state
4. Set up event subscriptions

### Performance Optimizations

#### Efficient Listing
```typescript
// Use Bun.Glob for efficient file system scanning
const glob = new Bun.Glob("**/*");
for await (const item of glob.scan({
  cwd: storageDir,
  onlyFiles: true,
})) {
  // Process file
}
```

#### Lazy Loading
- **Directory Creation**: Directories created on first write
- **File Reading**: Files read only when accessed
- **Index Caching**: No persistent indices (rely on file system)

#### Memory Management
- **No Persistent Cache**: Files read directly from disk
- **Temporary Cleanup**: Automatic cleanup of temporary files
- **Event Debouncing**: Batch related storage events

### Error Handling

#### File System Errors
```typescript
async function safeRead<T>(key: string, defaultValue: T): Promise<T> {
  try {
    return await readJSON(key);
  } catch (error) {
    if (error.code === "ENOENT") {
      return defaultValue;
    }
    throw error;
  }
}
```

#### Recovery Strategies
- **Missing Files**: Return default values or throw appropriate errors
- **Corrupted Data**: Log errors, continue with degraded functionality
- **Permission Errors**: Clear error messages with remediation steps
- **Disk Full**: Graceful degradation, cleanup old data

#### Backup and Recovery
- **No Automatic Backup**: Users responsible for backup
- **Export Support**: Data can be exported as JSON
- **Import Support**: Data can be imported from JSON
- **Migration**: Support for data format migrations

### Security Considerations

#### File Permissions
- **User-only Access**: Storage directory restricted to user
- **Sensitive Data**: Authentication data has 0o600 permissions
- **Temporary Files**: Secure cleanup of temporary files

#### Data Privacy
- **Local Storage**: All data stored locally by default
- **Sharing Opt-in**: Sharing requires explicit user action
- **Encryption**: No at-rest encryption (file system dependent)

### Integration Points

#### Share Synchronization
```typescript
// Automatic synchronization with sharing service
Bus.subscribe(Storage.Event.Write, async (payload) => {
  const [root, ...splits] = payload.properties.key.split("/");
  if (root === "session") {
    await Share.sync(payload.properties.key, payload.properties.content);
  }
});
```

#### Message Management
```typescript
// Session and message lifecycle management
export async function messages(sessionID: string): Promise<Message.Info[]> {
  const result: Message.Info[] = [];
  const list = Storage.list("session/message/" + sessionID);
  
  for await (const path of list) {
    const message = await Storage.readJSON<Message.Info>(path);
    result.push(message);
  }
  
  return result.sort((a, b) => (a.id > b.id ? 1 : -1));
}
```

### Monitoring and Diagnostics

#### Storage Metrics
- **Storage Usage**: Track total storage size per project
- **File Counts**: Monitor number of stored entities
- **Operation Performance**: Track read/write operation times
- **Error Rates**: Monitor storage operation failures

#### Diagnostic Tools
```typescript
async function getStorageStats(): Promise<{
  totalSize: number;
  fileCount: number;
  sessionCount: number;
  messageCount: number;
}> {
  // Calculate storage statistics
}
```

### Future Enhancements

#### Advanced Features
- **Compression**: Compress large data files
- **Indexing**: Secondary indices for faster queries
- **Encryption**: Optional at-rest encryption
- **Versioning**: Data versioning and history

#### Performance Improvements
- **Write Coalescing**: Batch multiple writes
- **Read Caching**: In-memory read cache
- **Async Operations**: Fully asynchronous I/O
- **Parallel Processing**: Concurrent read/write operations

#### Alternative Backends
- **SQLite**: Structured query support
- **Cloud Storage**: Remote storage backends
- **Database Integration**: Enterprise database support
- **Distributed Storage**: Multi-node storage systems
