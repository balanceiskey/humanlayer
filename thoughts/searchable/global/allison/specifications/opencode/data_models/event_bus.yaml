---
component: Event Bus
version: "1.0.0"
category: Core Data Model
description: Event-driven communication and state synchronization
---

# Event Bus Data Model

## Overview
The Event Bus provides a type-safe, centralized event system for decoupled communication between application components, enabling reactive updates and state synchronization.

## Entity: Event System

### Purpose
- Enable decoupled component communication
- Provide type-safe event definitions
- Support reactive UI updates
- Coordinate state changes across application

### Core Architecture
```typescript
namespace Bus {
  function event<Type extends string, Properties extends ZodType>(
    type: Type,
    properties: Properties
  ): EventDefinition;
  
  function publish<Definition extends EventDefinition>(
    def: Definition,
    properties: z.output<Definition["properties"]>
  ): void;
  
  function subscribe<Definition extends EventDefinition>(
    def: Definition,
    callback: (event) => void
  ): () => void;
}
```

### Event Definition System

#### Event Definition Structure
```typescript
interface EventDefinition {
  type: string;                        // Event type identifier
  properties: ZodType;                 // Event payload schema
}

function event<Type extends string, Properties extends ZodType>(
  type: Type,
  properties: Properties
) {
  const result = { type, properties };
  registry.set(type, result);
  return result;
}
```

#### Type Safety
Events are statically typed using TypeScript and runtime validated with Zod:
```typescript
const UserLoggedIn = Bus.event(
  "user.logged_in",
  z.object({
    userId: z.string(),
    timestamp: z.number(),
    provider: z.string()
  })
);

// Type-safe publishing
Bus.publish(UserLoggedIn, {
  userId: "usr_123",
  timestamp: Date.now(),
  provider: "anthropic"
});

// Type-safe subscription
Bus.subscribe(UserLoggedIn, (event) => {
  // event.properties is properly typed
  console.log(`User ${event.properties.userId} logged in`);
});
```

### Core Event Categories

#### Session Events
```typescript
export const Session = {
  Updated: Bus.event(
    "session.updated",
    z.object({
      info: Session.Info
    })
  ),
  
  Deleted: Bus.event(
    "session.deleted", 
    z.object({
      info: Session.Info
    })
  ),
  
  Error: Bus.event(
    "session.error",
    z.object({
      error: Message.Info.shape.metadata.shape.error
    })
  )
};
```

#### Message Events
```typescript
export const Message = {
  Updated: Bus.event(
    "message.updated",
    z.object({
      info: Message.Info
    })
  ),
  
  PartUpdated: Bus.event(
    "message.part.updated",
    z.object({
      part: Message.Part,
      sessionID: z.string(),
      messageID: z.string()
    })
  )
};
```

#### Storage Events
```typescript
export const Storage = {
  Write: Bus.event(
    "storage.write",
    z.object({
      key: z.string(),
      content: z.any()
    })
  )
};
```

#### Permission Events
```typescript
export const Permission = {
  Updated: Bus.event(
    "permission.updated",
    Permission.Info
  )
};
```

### Event Payload Structure

#### Standard Event Format
```typescript
interface EventPayload<T> {
  type: string;                        // Event type
  properties: T;                       // Typed event data
}
```

#### Event Serialization
Events are serialized for transmission and logging:
```json
{
  "type": "session.updated",
  "properties": {
    "info": {
      "id": "ses_01h2k3...",
      "title": "New Session",
      "time": {
        "created": 1705315800000,
        "updated": 1705316400000
      }
    }
  }
}
```

### Subscription Management

#### Subscription Interface
```typescript
type Subscription = (event: any) => void;

interface SubscriptionManager {
  subscriptions: Map<string, Subscription[]>;
  
  subscribe(type: string, callback: Subscription): () => void;
  unsubscribe(type: string, callback: Subscription): void;
  publish(type: string, payload: any): void;
}
```

#### Wildcard Subscriptions
```typescript
// Subscribe to all events
Bus.subscribeAll((event) => {
  console.log(`Event: ${event.type}`, event.properties);
});

// Subscribe using wildcard
Bus.subscribe("*", (event) => {
  // Receives all events
});
```

#### Once Subscriptions
```typescript
Bus.once(Session.Updated, (event) => {
  console.log("Session updated once");
  return "done"; // Auto-unsubscribe
});
```

### State Management Integration

#### Application State
```typescript
const state = App.state("bus", () => {
  const subscriptions = new Map<any, Subscription[]>();
  return { subscriptions };
});
```

#### Reactive Updates
Components subscribe to relevant events for reactive updates:
```typescript
// UI component subscribing to message updates
Bus.subscribe(Message.PartUpdated, (event) => {
  const { part, sessionID, messageID } = event.properties;
  updateUI(sessionID, messageID, part);
});
```

### Event Processing

#### Synchronous Publishing
```typescript
function publish<Definition extends EventDefinition>(
  def: Definition,
  properties: z.output<Definition["properties"]>
) {
  const payload = { type: def.type, properties };
  
  // Publish to specific subscribers
  const specificSubs = state().subscriptions.get(def.type) ?? [];
  for (const sub of specificSubs) {
    sub(payload);
  }
  
  // Publish to wildcard subscribers
  const wildcardSubs = state().subscriptions.get("*") ?? [];
  for (const sub of wildcardSubs) {
    sub(payload);
  }
}
```

#### Error Handling
```typescript
function safePublish(type: string, payload: any) {
  const subscribers = state().subscriptions.get(type) ?? [];
  
  for (const subscriber of subscribers) {
    try {
      subscriber(payload);
    } catch (error) {
      log.error("Event subscriber error", { type, error });
    }
  }
}
```

### Schema Generation

#### OpenAPI Integration
```typescript
function payloads() {
  return z.discriminatedUnion(
    "type",
    registry
      .entries()
      .map(([type, def]) =>
        z.object({
          type: z.literal(type),
          properties: def.properties,
        }).openapi({
          ref: "Event" + "." + def.type,
        })
      )
      .toArray() as any,
  );
}
```

#### Runtime Schema Validation
Event payloads are validated at runtime:
```typescript
function validateEvent(event: unknown): EventPayload<any> {
  const schema = payloads();
  return schema.parse(event);
}
```

### Event Flow Examples

#### Session Creation Flow
1. **Session.create()** called
2. Session data written to storage
3. **Storage.Write** event published
4. Share.sync() triggered by storage event
5. **Session.Updated** event published
6. UI components update session list

#### Message Streaming Flow
1. **Message.chat()** starts streaming
2. Text parts created incrementally
3. **Message.PartUpdated** events published
4. UI updates message display in real-time
5. Tool invocations trigger additional part updates
6. **Message.Updated** event on completion

#### Error Propagation Flow
1. Provider authentication fails
2. **Session.Error** event published
3. Error handler displays user notification
4. Recovery mechanisms triggered
5. Authentication re-attempted

### Performance Considerations

#### Subscription Management
- **Efficient Lookups**: Map-based subscription storage
- **Memory Management**: Automatic cleanup of dead subscriptions
- **Batch Processing**: Group related events when possible

#### Event Debouncing
```typescript
function debounceEvents(eventType: string, delay: number) {
  let timeoutId: Timer;
  const pendingEvents: any[] = [];
  
  return (event: any) => {
    pendingEvents.push(event);
    clearTimeout(timeoutId);
    
    timeoutId = setTimeout(() => {
      Bus.publish(eventType, { events: pendingEvents });
      pendingEvents.length = 0;
    }, delay);
  };
}
```

#### Memory Optimization
- **Weak References**: Use weak references for transient subscribers
- **Subscription Cleanup**: Automatic unsubscription on component unmount
- **Event Pooling**: Reuse event objects when possible

### Integration Patterns

#### Component Integration
```typescript
class SessionManager {
  constructor() {
    // Subscribe to relevant events
    this.unsubscribe = [
      Bus.subscribe(Session.Updated, this.handleSessionUpdate),
      Bus.subscribe(Session.Error, this.handleSessionError)
    ];
  }
  
  destroy() {
    // Clean up subscriptions
    this.unsubscribe.forEach(fn => fn());
  }
  
  private handleSessionUpdate = (event) => {
    // Handle session updates
  };
}
```

#### Cross-Component Communication
```typescript
// Component A publishes event
Bus.publish(UserAction, { action: "file_selected", path: "/src/main.ts" });

// Component B subscribes and reacts
Bus.subscribe(UserAction, (event) => {
  if (event.properties.action === "file_selected") {
    this.loadFile(event.properties.path);
  }
});
```

### Debugging and Monitoring

#### Event Logging
```typescript
Bus.subscribeAll((event) => {
  log.debug("Event published", {
    type: event.type,
    timestamp: Date.now(),
    size: JSON.stringify(event.properties).length
  });
});
```

#### Event History
```typescript
class EventHistory {
  private history: EventPayload<any>[] = [];
  
  constructor() {
    Bus.subscribeAll((event) => {
      this.history.push({
        ...event,
        timestamp: Date.now()
      });
      
      // Keep only recent events
      if (this.history.length > 1000) {
        this.history.shift();
      }
    });
  }
  
  getHistory(type?: string): EventPayload<any>[] {
    return type 
      ? this.history.filter(e => e.type === type)
      : this.history;
  }
}
```

### Error Handling

#### Subscription Errors
```typescript
function safeSubscribe(eventDef: EventDefinition, callback: Function) {
  return Bus.subscribe(eventDef, (event) => {
    try {
      callback(event);
    } catch (error) {
      log.error("Event handler error", { 
        eventType: event.type, 
        error: error.message 
      });
    }
  });
}
```

#### Event Validation Errors
```typescript
function publishWithValidation(eventDef: EventDefinition, properties: any) {
  try {
    const validated = eventDef.properties.parse(properties);
    Bus.publish(eventDef, validated);
  } catch (error) {
    log.error("Event validation failed", { 
      eventType: eventDef.type, 
      error: error.message 
    });
  }
}
```

### Future Enhancements

#### Advanced Features
- **Event Persistence**: Store events for replay and debugging
- **Event Sourcing**: Build application state from event history
- **Remote Events**: Synchronize events across instances
- **Event Middleware**: Transform events through middleware pipeline

#### Performance Improvements
- **Async Publishing**: Non-blocking event publishing
- **Priority Events**: Priority-based event processing
- **Event Batching**: Batch related events for efficiency
- **Subscription Optimization**: Optimize subscription matching

#### Developer Experience
- **Event Inspector**: Visual event debugging tools
- **Type Generation**: Auto-generate event types from schemas
- **Event Testing**: Tools for testing event flows
- **Performance Profiling**: Event system performance monitoring
