---
component: Tool
version: "1.0.0"
category: Core Data Model
description: Tool definitions and execution framework
---

# Tool Data Model

## Overview
The Tool system provides a standardized interface for AI agents to interact with external systems, execute commands, and manipulate data through a type-safe execution framework.

## Entity: Tool.Info

### Purpose
- Define available tools for AI agents
- Standardize tool execution interface
- Provide type-safe parameter validation
- Track tool execution metadata and results

### Schema Definition
```typescript
interface ToolInfo<
  Parameters extends StandardSchemaV1 = StandardSchemaV1,
  M extends Metadata = Metadata
> {
  id: string;                          // Unique tool identifier
  description: string;                 // Human-readable description
  parameters: Parameters;              // Parameter schema
  execute(                            // Execution function
    args: StandardSchemaV1.InferOutput<Parameters>,
    ctx: ToolContext
  ): Promise<ToolResult<M>>;
}
```

### Core Interfaces

#### Tool Context
```typescript
interface ToolContext<M extends Metadata = Metadata> {
  sessionID: string;                   // Current session
  messageID: string;                   // Current message
  abort: AbortSignal;                  // Cancellation signal
  metadata(meta: M): void;             // Metadata callback
}
```

#### Tool Result
```typescript
interface ToolResult<M extends Metadata> {
  metadata: M;                         // Execution metadata
  output: string;                      // Tool output content
}
```

#### Base Metadata
```typescript
interface Metadata {
  title: string;                       // Human-readable title
  [key: string]: any;                  // Additional metadata
}
```

### Built-in Tool Definitions

#### BashTool
```typescript
interface BashToolParams {
  command: string;                     // Shell command to execute
  cwd?: string;                        // Working directory
}

interface BashToolMetadata extends Metadata {
  command: string;                     // Executed command
  exitCode: number;                    // Process exit code
  cwd: string;                         // Working directory
  duration: number;                    // Execution time (ms)
}
```

#### ReadTool
```typescript
interface ReadToolParams {
  path: string;                        // File path to read
  range?: [number, number];            // Optional line range
}

interface ReadToolMetadata extends Metadata {
  path: string;                        // File path
  size: number;                        // File size in bytes
  lines: number;                       // Total line count
  encoding: string;                    // File encoding
}
```

#### WriteTool
```typescript
interface WriteToolParams {
  path: string;                        // File path to write
  content: string;                     // File content
}

interface WriteToolMetadata extends Metadata {
  path: string;                        // File path
  size: number;                        // Written bytes
  created: boolean;                    // New file flag
}
```

#### EditTool
```typescript
interface EditToolParams {
  path: string;                        // File path to edit
  oldStr: string;                      // Text to replace
  newStr: string;                      // Replacement text
  replaceAll?: boolean;                // Replace all occurrences
}

interface EditToolMetadata extends Metadata {
  path: string;                        // File path
  matches: number;                     // Replacement count
  lineRange: [number, number];         // Affected line range
}
```

#### GrepTool
```typescript
interface GrepToolParams {
  pattern: string;                     // Search pattern
  path?: string;                       // Search path
  caseSensitive?: boolean;             // Case sensitivity
}

interface GrepToolMetadata extends Metadata {
  pattern: string;                     // Search pattern
  matches: number;                     // Match count
  files: number;                       // File count
}
```

#### GlobTool
```typescript
interface GlobToolParams {
  pattern: string;                     // Glob pattern
  limit?: number;                      // Result limit
  offset?: number;                     // Result offset
}

interface GlobToolMetadata extends Metadata {
  pattern: string;                     // Glob pattern
  matches: number;                     // Match count
  truncated: boolean;                  // Results truncated
}
```

#### WebFetchTool
```typescript
interface WebFetchToolParams {
  url: string;                         // URL to fetch
  method?: "GET" | "POST";             // HTTP method
  headers?: Record<string, string>;    // HTTP headers
  body?: string;                       // Request body
}

interface WebFetchToolMetadata extends Metadata {
  url: string;                         // Requested URL
  status: number;                      // HTTP status code
  contentType: string;                 // Response content type
  size: number;                        // Response size
}
```

#### LspDiagnosticTool
```typescript
interface LspDiagnosticToolParams {
  path: string;                        // File or directory path
}

interface LspDiagnosticToolMetadata extends Metadata {
  path: string;                        // Analyzed path
  errors: number;                      // Error count
  warnings: number;                    // Warning count
  info: number;                        // Info count
}
```

#### TodoTool
```typescript
interface TodoWriteToolParams {
  items: Array<{
    id: string;                        // Todo item ID
    text: string;                      // Todo description
    completed?: boolean;               // Completion status
  }>;
}

interface TodoReadToolParams {
  // No parameters - reads all todos
}
```

### Tool Registration System

#### Provider Tools
Tools are automatically loaded from provider configurations:

```typescript
async function getProviderTools(providerID: string): Promise<Tool.Info[]> {
  // Load built-in tools
  const builtinTools = [
    BashTool,
    ReadTool, 
    WriteTool,
    EditTool,
    GrepTool,
    GlobTool,
    WebFetchTool,
    LspDiagnosticTool,
    TodoReadTool,
    TodoWriteTool
  ];
  
  // Transform to AI SDK format
  return builtinTools.map(tool => ({
    id: tool.id,
    description: tool.description,
    parameters: tool.parameters,
    execute: tool.execute
  }));
}
```

#### MCP Tools
Model Context Protocol tools are dynamically loaded:

```typescript
interface McpTool {
  name: string;                        // Tool name
  description: string;                 // Tool description
  inputSchema: object;                 // JSON schema
  execute?: (args: any, opts: any) => Promise<any>;
}
```

### Execution Framework

#### Tool Context Management
```typescript
class ToolExecutionContext {
  sessionID: string;
  messageID: string;
  abort: AbortSignal;
  
  async metadata(meta: Metadata): Promise<void> {
    // Update message metadata
    // Trigger UI updates
  }
}
```

#### Error Handling
```typescript
interface ToolError {
  error: boolean;                      // Error flag
  message: string;                     // Error description
  title: string;                       // Error title
  time: {
    start: number;                     // Start timestamp
    end: number;                       // End timestamp
  };
}
```

#### Execution Tracking
```typescript
interface ToolExecutionRecord {
  toolCallId: string;                  // Unique call ID
  toolName: string;                    // Tool identifier
  args: unknown;                       // Tool arguments
  result?: string;                     // Execution result
  metadata: Metadata;                  // Execution metadata
  duration: number;                    // Execution time
}
```

### Parameter Validation

#### Schema System
Tools use Standard Schema V1 for parameter validation:

```typescript
import { z } from "zod";

const BashToolSchema = z.object({
  command: z.string().describe("Shell command to execute"),
  cwd: z.string().optional().describe("Working directory")
});
```

#### Runtime Validation
```typescript
function validateToolArgs<T>(
  schema: StandardSchemaV1,
  args: unknown
): T {
  // Runtime validation using schema
  // Throw validation errors for invalid input
  // Return typed arguments for execution
}
```

### Storage Strategy

#### Tool Metadata Storage
Tool execution metadata is embedded in message metadata:

```typescript
{
  "metadata": {
    "tool": {
      "call_123": {
        "title": "Reading configuration file",
        "time": {
          "start": 1705315810000,
          "end": 1705315812000
        },
        "path": "config.json",
        "size": 1024,
        "lines": 45
      }
    }
  }
}
```

#### Tool Result Caching
- **No Persistent Cache**: Tool results are not cached
- **Session Scope**: Results only available within session
- **Memory Cleanup**: Results cleaned up with message deletion

### Security Model

#### Permission System
```typescript
interface ToolPermission {
  id: string;                          // Permission identifier
  sessionID: string;                   // Session context
  title: string;                       // Human-readable permission
  metadata: Record<string, any>;       // Permission metadata
}
```

#### Execution Sandboxing
- **Process Isolation**: Shell commands run in separate processes
- **Working Directory**: Restricted to project root
- **Resource Limits**: Timeout and memory constraints
- **Abort Signals**: Cancellable operations

#### File System Access
- **Path Validation**: Prevent directory traversal
- **Read Permissions**: Configurable file access patterns
- **Write Restrictions**: Limited to project directories
- **Temporary Files**: Secure cleanup of temporary data

### Data Flow

#### Tool Registration
1. Load built-in tool definitions
2. Register with AI SDK tool system
3. Validate schemas and interfaces
4. Enable tool discovery for AI agents

#### Tool Execution
1. AI agent requests tool invocation
2. Validate arguments against schema
3. Create execution context with metadata
4. Execute tool with timeout and abort signal
5. Capture result and execution metadata
6. Update message with tool result
7. Continue AI generation with tool output

#### Error Recovery
1. Catch tool execution errors
2. Create error metadata record
3. Return error message to AI agent
4. Log error details for debugging
5. Continue processing other tools

### Performance Considerations

#### Concurrent Execution
- **Parallel Tools**: Multiple tools can execute simultaneously
- **Resource Management**: CPU and memory limits enforced
- **Abort Handling**: Graceful cancellation of running tools

#### Large Output Handling
- **Streaming Results**: Large outputs streamed incrementally
- **Truncation**: Automatic truncation of oversized results
- **Compression**: Large tool outputs compressed in storage

#### Memory Management
- **Bounded Execution**: Tool execution memory limits
- **Cleanup**: Automatic cleanup of tool resources
- **Garbage Collection**: Regular cleanup of expired data

### Validation Rules

#### Tool Definition
- Unique tool identifiers within provider
- Valid Standard Schema V1 parameters
- Required execute function implementation
- Proper error handling in execution

#### Parameter Validation
- Schema validation before execution
- Type safety enforcement
- Required field validation
- Custom validation rules per tool

#### Result Validation
- Valid metadata structure
- String output requirement
- Execution timing consistency
- Error state handling

### Event Integration

#### Tool Events
```typescript
// Tool execution start
{
  "type": "tool.execution.start",
  "properties": {
    "toolCallId": "call_123",
    "toolName": "read_file",
    "sessionID": "ses_01h2k3...",
    "messageID": "msg_01h2k4..."
  }
}

// Tool execution complete
{
  "type": "tool.execution.complete", 
  "properties": {
    "toolCallId": "call_123",
    "result": "File contents...",
    "metadata": { /* ToolMetadata */ },
    "duration": 150
  }
}
```

#### Integration with Message Events
Tool execution updates trigger message part updates through the existing event system.

### Extensibility

#### Custom Tool Development
```typescript
const CustomTool = Tool.define({
  id: "custom_tool",
  description: "Custom tool implementation",
  parameters: z.object({
    input: z.string()
  }),
  async execute(args, ctx) {
    // Custom tool logic
    return {
      metadata: { title: "Custom Tool" },
      output: "Tool result"
    };
  }
});
```

#### Plugin System
Future support for dynamically loaded tools through plugin architecture.

#### MCP Integration
Seamless integration with Model Context Protocol for external tool providers.
