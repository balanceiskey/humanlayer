---
component: Auth
version: "1.0.0"
category: Core Data Model
description: Authentication and credential management
---

# Authentication Data Model

## Overview
The Authentication system manages API keys and OAuth credentials for AI providers, supporting multiple authentication methods with secure credential storage.

## Entity: Auth.Info

### Purpose
- Store provider authentication credentials
- Support multiple authentication methods
- Secure credential management
- Enable OAuth token refresh workflows

### Schema Definition
```typescript
type AuthInfo = OAuthInfo | ApiKeyInfo;

interface OAuthInfo {
  type: "oauth";
  refresh: string;                     // Refresh token
  access: string;                      // Access token
  expires: number;                     // Expiration timestamp
}

interface ApiKeyInfo {
  type: "api";
  key: string;                         // API key
}
```

### Authentication Types

#### OAuth Authentication
Used for providers supporting OAuth 2.0 flows:

```typescript
interface OAuthInfo {
  type: "oauth";
  refresh: string;                     // Long-lived refresh token
  access: string;                      // Short-lived access token
  expires: number;                     // Unix timestamp expiration
}
```

**Supported Providers:**
- Anthropic (OAuth 2.0 with PKCE)
- GitHub Copilot (Device Flow)

#### API Key Authentication
Used for providers with direct API key authentication:

```typescript
interface ApiKeyInfo {
  type: "api";
  key: string;                         // Provider API key
}
```

**Supported Providers:**
- OpenAI
- Custom providers
- Environment variable providers

### Storage Strategy

#### File Storage
- **Location**: `~/.local/share/opencode/auth.json`
- **Format**: JSON with provider-keyed credentials
- **Permissions**: 0o600 (owner read/write only)
- **Structure**:
```json
{
  "anthropic": {
    "type": "oauth",
    "refresh": "refresh_token_here",
    "access": "access_token_here", 
    "expires": 1705315800000
  },
  "openai": {
    "type": "api",
    "key": "sk-..."
  }
}
```

#### Security Measures
- **File Permissions**: Restricted to owner only
- **No Logging**: Credentials never logged
- **Memory Protection**: Credentials cleared from memory
- **Atomic Writes**: Secure file updates

### OAuth Implementation Details

#### Anthropic OAuth Flow

##### Authorization Request
```typescript
interface AuthorizationRequest {
  client_id: string;                   // Application client ID
  response_type: "code";               // OAuth response type
  redirect_uri: string;                // Callback URL
  scope: string;                       // Requested permissions
  code_challenge: string;              // PKCE code challenge
  code_challenge_method: "S256";       // PKCE method
}
```

##### Token Exchange
```typescript
interface TokenExchangeRequest {
  grant_type: "authorization_code";
  client_id: string;
  code: string;                        // Authorization code
  redirect_uri: string;
  code_verifier: string;               // PKCE code verifier
}

interface TokenResponse {
  access_token: string;
  refresh_token: string;
  expires_in: number;                  // Seconds until expiration
  token_type: "Bearer";
}
```

##### Token Refresh
```typescript
interface RefreshRequest {
  grant_type: "refresh_token";
  client_id: string;
  refresh_token: string;
}
```

#### GitHub Copilot Device Flow

##### Device Authorization
```typescript
interface DeviceCodeRequest {
  client_id: string;
  scope: string;
}

interface DeviceCodeResponse {
  device_code: string;                 // Device verification code
  user_code: string;                   // User display code
  verification_uri: string;            // Verification URL
  expires_in: number;                  // Code expiration
  interval: number;                    // Polling interval
}
```

##### Token Polling
```typescript
interface TokenRequest {
  client_id: string;
  device_code: string;
  grant_type: "urn:ietf:params:oauth:grant-type:device_code";
}

interface CopilotTokenRequest {
  code: string;                        // GitHub access token
}

interface CopilotTokenResponse {
  token: string;                       // Copilot access token
  expires_at: number;                  // Expiration timestamp
}
```

### Authentication Workflows

#### Provider Authentication Check
```typescript
async function getProviderAuth(providerID: string): Promise<AuthInfo | undefined> {
  const auth = await Auth.get(providerID);
  
  if (!auth) return undefined;
  
  if (auth.type === "oauth" && auth.expires < Date.now()) {
    // Attempt token refresh
    const refreshed = await refreshToken(providerID, auth.refresh);
    if (refreshed) {
      await Auth.set(providerID, refreshed);
      return refreshed;
    }
    return undefined;
  }
  
  return auth;
}
```

#### OAuth Token Refresh
```typescript
async function refreshToken(providerID: string, refreshToken: string): Promise<OAuthInfo | null> {
  const provider = getProvider(providerID);
  
  const response = await fetch(provider.tokenEndpoint, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      grant_type: "refresh_token",
      client_id: provider.clientId,
      refresh_token: refreshToken
    })
  });
  
  if (!response.ok) return null;
  
  const data = await response.json();
  return {
    type: "oauth",
    access: data.access_token,
    refresh: data.refresh_token,
    expires: Date.now() + (data.expires_in * 1000)
  };
}
```

### Provider Integration

#### Anthropic Integration
```typescript
export namespace AuthAnthropic {
  export async function authorize(): Promise<void> {
    const codeVerifier = generateCodeVerifier();
    const codeChallenge = generateCodeChallenge(codeVerifier);
    
    const authUrl = new URL("https://console.anthropic.com/oauth/authorize");
    authUrl.searchParams.set("client_id", CLIENT_ID);
    authUrl.searchParams.set("response_type", "code");
    authUrl.searchParams.set("redirect_uri", REDIRECT_URI);
    authUrl.searchParams.set("scope", "console:code");
    authUrl.searchParams.set("code_challenge", codeChallenge);
    authUrl.searchParams.set("code_challenge_method", "S256");
    
    // Open browser for user authorization
    await openBrowser(authUrl.toString());
    
    // Wait for callback with authorization code
    const code = await waitForCallback();
    
    // Exchange code for tokens
    const tokens = await exchangeCodeForTokens(code, codeVerifier);
    
    await Auth.set("anthropic", {
      type: "oauth",
      ...tokens
    });
  }
  
  export async function access(): Promise<string | null> {
    const auth = await Auth.get("anthropic");
    if (!auth || auth.type !== "oauth") return null;
    
    if (auth.expires < Date.now()) {
      const refreshed = await refreshTokens(auth.refresh);
      if (!refreshed) return null;
      
      await Auth.set("anthropic", {
        type: "oauth",
        ...refreshed
      });
      
      return refreshed.access;
    }
    
    return auth.access;
  }
}
```

#### GitHub Copilot Integration
```typescript
export namespace AuthCopilot {
  export async function authorize(): Promise<void> {
    // Step 1: Get device code
    const deviceResponse = await requestDeviceCode();
    
    // Step 2: Show user code to user
    console.log(`Visit: ${deviceResponse.verification_uri}`);
    console.log(`Code: ${deviceResponse.user_code}`);
    
    // Step 3: Poll for token
    const githubToken = await pollForToken(deviceResponse);
    
    // Step 4: Exchange for Copilot token
    const copilotToken = await getCopilotToken(githubToken.access_token);
    
    await Auth.set("github-copilot", {
      type: "oauth",
      access: copilotToken.token,
      refresh: githubToken.refresh_token,
      expires: copilotToken.expires_at
    });
  }
}
```

### Error Handling

#### Authentication Errors
```typescript
export class AuthError extends NamedError {
  constructor(
    public readonly providerID: string,
    public readonly message: string
  ) {
    super(`Authentication failed for ${providerID}: ${message}`);
  }
}

export class TokenExpiredError extends AuthError {
  constructor(providerID: string) {
    super(providerID, "Access token has expired");
  }
}

export class RefreshFailedError extends AuthError {
  constructor(providerID: string) {
    super(providerID, "Failed to refresh access token");
  }
}
```

#### Error Recovery
- **Token Expiration**: Automatic refresh attempts
- **Refresh Failure**: Clear credentials, require re-authentication
- **Network Errors**: Retry with exponential backoff
- **Invalid Credentials**: Clear and prompt for re-authentication

### Data Access Patterns

#### Provider Authentication
```typescript
// Check if provider has valid authentication
const auth = await Auth.get("anthropic");
const isAuthenticated = auth && (
  auth.type === "api" || 
  (auth.type === "oauth" && auth.expires > Date.now())
);
```

#### API Request Authentication
```typescript
// Apply authentication to HTTP requests
function authenticateRequest(request: Request, auth: AuthInfo): Request {
  if (auth.type === "api") {
    request.headers.set("Authorization", `Bearer ${auth.key}`);
  } else if (auth.type === "oauth") {
    request.headers.set("Authorization", `Bearer ${auth.access}`);
  }
  return request;
}
```

### Security Best Practices

#### Credential Protection
- **No Plaintext Logging**: Credentials never appear in logs
- **Memory Clearing**: Sensitive data cleared after use
- **File Permissions**: Restrictive file system permissions
- **Environment Isolation**: Separate credential storage per project

#### Token Management
- **Expiration Handling**: Proactive token refresh
- **Scope Limitation**: Minimal required OAuth scopes
- **Rotation**: Support for credential rotation
- **Revocation**: Clean credential removal on revocation

#### Network Security
- **HTTPS Only**: All authentication requests over HTTPS
- **Certificate Validation**: Strict TLS certificate validation
- **Request Signing**: PKCE for OAuth flows
- **Replay Protection**: Nonce-based replay protection

### Performance Considerations

#### Token Refresh Optimization
- **Proactive Refresh**: Refresh before expiration
- **Caching**: Cache valid tokens in memory
- **Batching**: Batch multiple refresh requests
- **Background Refresh**: Non-blocking token refresh

#### Storage Efficiency
- **Minimal Storage**: Only essential credential data
- **Atomic Operations**: Atomic file updates
- **Lock-Free Reads**: Non-blocking credential reads
- **Cleanup**: Automatic cleanup of expired credentials

### Monitoring and Diagnostics

#### Authentication Metrics
- **Success Rates**: Track authentication success/failure
- **Token Refresh Frequency**: Monitor refresh patterns
- **Error Classification**: Categorize authentication errors
- **Performance Tracking**: Monitor authentication latency

#### Debug Information
- **Token Status**: Check token validity and expiration
- **Provider Status**: Check provider authentication state
- **Error Details**: Detailed error information for debugging
- **Audit Trail**: Track authentication events (without secrets)

### Future Considerations

#### Additional Authentication Methods
- **SAML**: Enterprise authentication support
- **OpenID Connect**: Standards-based identity
- **Certificate Auth**: Client certificate authentication
- **Multi-Factor**: Two-factor authentication support

#### Enhanced Security
- **Hardware Security**: Hardware token support
- **Encryption at Rest**: Encrypted credential storage
- **Key Derivation**: Derived keys for credential protection
- **Audit Logging**: Secure audit trail for compliance
