---
component: Provider
version: "1.0.0"
category: Core Data Model
description: AI provider and model management system
---

# Provider Data Model

## Overview
The Provider system manages AI model providers, their configurations, and model metadata, enabling dynamic provider loading and unified model access across different AI services.

## Entity: Provider Configuration

### Purpose
- Define AI model providers and their capabilities
- Manage provider authentication and configuration
- Standardize model access across different providers
- Support dynamic provider loading and customization

### Core Schemas

#### Provider Definition
```typescript
interface ProviderInfo {
  api?: string;                        // Provider API endpoint
  name: string;                        // Human-readable name
  env: string[];                       // Required environment variables
  id: string;                          // Unique provider identifier
  npm?: string;                        // NPM package for dynamic loading
  models: Record<string, ModelInfo>;   // Available models
}
```

#### Model Definition
```typescript
interface ModelInfo {
  name: string;                        // Human-readable model name
  attachment: boolean;                 // File attachment support
  reasoning: boolean;                  // Reasoning capabilities
  temperature: boolean;                // Temperature control support
  tool_call: boolean;                  // Tool calling capabilities
  cost: CostInfo;                      // Token cost information
  limit: LimitInfo;                    // Model limitations
  id: string;                          // Provider-specific model ID
  options: Record<string, any>;        // Provider-specific options
}
```

#### Cost Information
```typescript
interface CostInfo {
  input: number;                       // Input tokens per million
  output: number;                      // Output tokens per million
  cache_read?: number;                 // Cache read cost per million
  cache_write?: number;                // Cache write cost per million
}
```

#### Limit Information
```typescript
interface LimitInfo {
  context: number;                     // Maximum context window
  output: number;                      // Maximum output tokens
}
```

### Provider Registry

#### Built-in Providers
The system includes configurations for major AI providers:

**Anthropic**
- Models: Claude 3.5 Sonnet, Claude 3 Haiku, etc.
- Authentication: OAuth 2.0
- Features: Reasoning, tool calling, attachments

**OpenAI**
- Models: GPT-4, GPT-3.5 Turbo variants
- Authentication: API key
- Features: Tool calling, attachments, temperature

**GitHub Copilot**
- Models: GPT-4, Claude variants
- Authentication: Device flow OAuth
- Features: Zero-cost for authenticated users

#### Dynamic Provider Loading
```typescript
interface CustomLoader {
  (provider: ProviderInfo, api?: string): Promise<{
    autoload: boolean;                 // Auto-enable provider
    getModel?: (sdk: any, modelID: string) => Promise<any>;
    options?: Record<string, any>;     // Custom provider options
  }>;
}
```

### Provider Sources

#### Environment Variables
Providers automatically loaded based on environment variables:
```typescript
type Source = "env" | "config" | "custom" | "api";

interface ProviderSource {
  source: Source;                      // Configuration source
  autoload: boolean;                   // Auto-enable flag
  provider: ProviderInfo;              // Provider configuration
  language?: LanguageModel;            // Loaded language model
}
```

#### Configuration Override
Project and global configurations can override provider settings:
```json
{
  "provider": {
    "anthropic": {
      "models": {
        "claude-3-5-sonnet-20241022": {
          "cost": {
            "input": 3.0,
            "output": 15.0,
            "cache_read": 0.3,
            "cache_write": 3.75
          }
        }
      }
    }
  }
}
```

#### NPM Package Loading
```typescript
async function loadNpmProvider(npmPackage: string): Promise<SDK> {
  const module = await import(npmPackage);
  return module.default || module;
}
```

### Authentication Integration

#### OAuth Providers
```typescript
const CUSTOM_LOADERS: Record<string, CustomLoader> = {
  async anthropic(provider) {
    const access = await AuthAnthropic.access();
    if (!access) return { autoload: false };
    
    // Override costs for authenticated users
    for (const model of Object.values(provider.models)) {
      model.cost = { input: 0, output: 0 };
    }
    
    return {
      autoload: true,
      options: {
        apiKey: "",
        async fetch(input: any, init: any) {
          const access = await AuthAnthropic.access();
          return fetch(input, {
            ...init,
            headers: {
              ...init.headers,
              authorization: `Bearer ${access}`,
              "anthropic-beta": "oauth-2025-04-20"
            }
          });
        }
      }
    };
  }
};
```

#### API Key Providers
```typescript
async function loadApiKeyProvider(providerID: string): Promise<ProviderSource | null> {
  const info = await Auth.get(providerID);
  if (!info || info.type !== "api") return null;
  
  return {
    source: "api",
    autoload: true,
    provider: await getProviderInfo(providerID),
    options: {
      apiKey: info.key
    }
  };
}
```

### Model Access Pattern

#### Model Resolution
```typescript
async function getModel(providerID: string, modelID: string): Promise<{
  info: ModelInfo;
  language: LanguageModel;
}> {
  const providers = await getAllProviders();
  const provider = providers.find(p => p.provider.id === providerID);
  
  if (!provider) {
    throw new NoSuchModelError({ modelId: `${providerID}/${modelID}` });
  }
  
  const model = provider.provider.models[modelID];
  if (!model) {
    throw new NoSuchModelError({ modelId: `${providerID}/${modelID}` });
  }
  
  const language = await provider.getModel?.(provider.language, modelID) 
    ?? provider.language(model.id);
  
  return { info: model, language };
}
```

#### Tool Integration
```typescript
async function getProviderTools(providerID: string): Promise<Tool.Info[]> {
  const builtinTools = [
    BashTool,
    ReadTool,
    WriteTool,
    EditTool,
    GrepTool,
    GlobTool,
    WebFetchTool,
    LspDiagnosticTool,
    TodoReadTool,
    TodoWriteTool
  ];
  
  return builtinTools.map(tool => ({
    id: tool.id.replaceAll(".", "_"),
    description: tool.description,
    parameters: tool.parameters,
    execute: tool.execute
  }));
}
```

### Configuration Management

#### Provider Discovery
```typescript
async function discoverProviders(): Promise<ProviderSource[]> {
  const sources: ProviderSource[] = [];
  const config = await Config.get();
  const models = await ModelsDev.get();
  
  // Load from environment variables
  for (const [providerID, provider] of Object.entries(models)) {
    const envSource = await loadFromEnvironment(providerID, provider);
    if (envSource) sources.push(envSource);
  }
  
  // Load from configuration
  for (const [providerID, customConfig] of Object.entries(config.provider ?? {})) {
    const configSource = await loadFromConfig(providerID, customConfig);
    if (configSource) sources.push(configSource);
  }
  
  // Load custom providers
  for (const [providerID, loader] of Object.entries(CUSTOM_LOADERS)) {
    const customSource = await loadCustomProvider(providerID, loader);
    if (customSource) sources.push(customSource);
  }
  
  return sources;
}
```

#### Configuration Merging
```typescript
function mergeProviderConfig(
  base: ProviderInfo,
  override: Partial<ProviderInfo>
): ProviderInfo {
  return {
    ...base,
    ...override,
    models: {
      ...base.models,
      ...Object.fromEntries(
        Object.entries(override.models ?? {}).map(([id, model]) => [
          id,
          { ...base.models[id], ...model }
        ])
      )
    }
  };
}
```

### Data Sources

#### Models.dev API
```typescript
export namespace ModelsDev {
  const API_URL = "https://models.dev/api.json";
  const CACHE_PATH = path.join(Global.Path.cache, "models.json");
  
  export async function get(): Promise<Record<string, ProviderInfo>> {
    // Try cache first
    const cached = await Bun.file(CACHE_PATH).json().catch(() => null);
    if (cached) {
      refresh(); // Background refresh
      return cached;
    }
    
    // Fetch fresh data
    const response = await fetch(API_URL).catch(() => null);
    if (response?.ok) {
      const data = await response.json();
      await Bun.write(CACHE_PATH, JSON.stringify(data));
      return data;
    }
    
    // Fallback to embedded data
    const embedded = await data();
    return JSON.parse(embedded);
  }
}
```

#### Embedded Provider Data
```typescript
// Generated at build time from models.dev
export const data = () => Promise.resolve(`{
  "anthropic": {
    "id": "anthropic",
    "name": "Anthropic",
    "env": ["ANTHROPIC_API_KEY"],
    "npm": "@ai-sdk/anthropic",
    "models": {
      "claude-3-5-sonnet-20241022": {
        "id": "claude-3-5-sonnet-20241022",
        "name": "Claude 3.5 Sonnet",
        "attachment": true,
        "reasoning": false,
        "temperature": true,
        "tool_call": true,
        "cost": {
          "input": 3.0,
          "output": 15.0,
          "cache_read": 0.3,
          "cache_write": 3.75
        },
        "limit": {
          "context": 200000,
          "output": 8192
        },
        "options": {}
      }
    }
  }
}`);
```

### Schema Transformation

#### AI SDK Integration
```typescript
function optionalToNullable(schema: z.ZodTypeAny): z.ZodTypeAny {
  if (schema instanceof z.ZodObject) {
    const shape = schema.shape;
    const newShape: Record<string, z.ZodTypeAny> = {};
    
    for (const [key, value] of Object.entries(shape)) {
      const zodValue = value as z.ZodTypeAny;
      if (zodValue instanceof z.ZodOptional) {
        newShape[key] = zodValue.unwrap().nullable();
      } else {
        newShape[key] = optionalToNullable(zodValue);
      }
    }
    
    return z.object(newShape);
  }
  
  if (schema instanceof z.ZodArray) {
    return z.array(optionalToNullable(schema.element));
  }
  
  if (schema instanceof z.ZodUnion) {
    return z.union(
      schema.options.map((option: z.ZodTypeAny) =>
        optionalToNullable(option)
      ) as [z.ZodTypeAny, z.ZodTypeAny, ...z.ZodTypeAny[]]
    );
  }
  
  return schema;
}
```

### Error Handling

#### Provider Errors
```typescript
export class AuthError extends NamedError {
  static readonly Schema = z.object({
    providerID: z.string(),
    message: z.string()
  });
  
  constructor(
    public readonly providerID: string,
    public readonly message: string
  ) {
    super(`Provider ${providerID} authentication failed: ${message}`);
  }
}

export class NoSuchModelError extends Error {
  constructor(public readonly modelId: string) {
    super(`Model ${modelId} not found`);
  }
}
```

#### Graceful Degradation
- **Missing Providers**: Skip unavailable providers
- **Authentication Failures**: Disable provider, show warning
- **Network Issues**: Use cached data, retry background refresh
- **Configuration Errors**: Use defaults, log validation errors

### Performance Considerations

#### Lazy Loading
- **Provider Discovery**: Lazy provider enumeration
- **Model Loading**: On-demand model instantiation
- **SDK Loading**: Dynamic import of provider SDKs
- **Authentication**: Cached authentication state

#### Caching Strategy
- **Provider Registry**: In-memory provider cache
- **Model Metadata**: Cached model information
- **API Responses**: Background refresh with cache fallback
- **Authentication**: Cached tokens with refresh

#### Resource Management
- **Memory Usage**: Cleanup unused provider instances
- **Network Requests**: Debounced API calls
- **Background Tasks**: Non-blocking refresh operations
- **Error Recovery**: Exponential backoff for failed requests

### Monitoring and Diagnostics

#### Provider Health
```typescript
interface ProviderHealth {
  id: string;                          // Provider identifier
  status: "active" | "inactive" | "error"; // Provider status
  authentication: "valid" | "expired" | "missing"; // Auth status
  lastCheck: number;                   // Last health check
  errorCount: number;                  // Recent error count
  models: string[];                    // Available models
}
```

#### Usage Metrics
- **Model Usage**: Track model usage by provider
- **Cost Tracking**: Monitor token costs across providers
- **Error Rates**: Track authentication and API errors
- **Performance**: Monitor response times and throughput

### Future Enhancements

#### Advanced Features
- **Model Routing**: Intelligent model selection
- **Load Balancing**: Distribute requests across providers
- **Fallback Chains**: Automatic failover between providers
- **Cost Optimization**: Automatic cost-aware model selection

#### Provider Ecosystem
- **Plugin System**: Third-party provider plugins
- **Custom Models**: Support for custom model deployments
- **Edge Providers**: Local and edge model support
- **Federated Providers**: Multi-tenant provider management
